/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/31 16:35:53 by dlesieur          #+#    #+#             */
/*   Updated: 2025/08/08 15:50:16 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "map.h"

static void	assign_signed(int neg, int value, int *out)
{
	if (neg)
		*out = -value;
	else
		*out = value;
}

bool	parse_numeric_value(t_parser *parser)
{
	t_ctx_data	*ctx;
	size_t		pos;
	int			value;
	int			neg;
	int			has;

	ctx = parser->context;
	pos = parser->position;
	value = 0;
	neg = 0;
	has = 0;
	if (pos < parser->buffer_size && parser->buffer[pos] == '-')
	{
		neg = 1;
		pos++;
	}
	else if (pos < parser->buffer_size && parser->buffer[pos] == '+')
		pos++;
	while (pos < parser->buffer_size
		&& parser->buffer[pos] >= '0' && parser->buffer[pos] <= '9')
	{
		value = value * 10 + (parser->buffer[pos] - '0');
		pos++;
		has = 1;
	}
	if (!has)
		return (false);
	assign_signed(neg, value, &ctx->z);
	parser->position = pos;
	return (true);
}

static void	color_prefix_skip(t_parser *p, size_t *pos)
{
	if (*pos + 1 < p->buffer_size
		&& p->buffer[*pos] == '0'
		&& (p->buffer[*pos + 1] == 'x'
			|| p->buffer[*pos + 1] == 'X'))
		*pos += 2;
}

bool	parse_color_value(t_parser *parser)
{
	t_ctx_data	*ctx;
	size_t		pos;
	uint32_t	color;
	int			digits;
	char		c;

	ctx = parser->context;
	pos = parser->position;
	if (pos >= parser->buffer_size || parser->buffer[pos] != ',')
	{
		ctx->current_color = 0xffffff;
		return (true);
	}
	pos++;
	color = 0;
	digits = 0;
	color_prefix_skip(parser, &pos);
	while (pos < parser->buffer_size && digits < 6)
	{
		c = parser->buffer[pos];
		if (c >= '0' && c <= '9')
			color = (color << 4) | (c - '0');
		else if (c >= 'a' && c <= 'f')
			color = (color << 4) | (c - 'a' + 10);
		else if (c >= 'A' && c <= 'F')
			color = (color << 4) | (c - 'A' + 10);
		else
			break ;
		pos++;
		digits++;
	}
	if (digits == 0)
		return (false);
	ctx->current_color = color;
	if (ctx->colors && ctx->values_read < ctx->array_capacity)
		ctx->colors[ctx->values_read] = color;
	parser->position = pos;
	return (true);
}

static void	parse_digits_dec(t_parser *p, size_t *pos, long *val, int *has)
{
	char	ch;

	while (*pos < p->buffer_size)
	{
		ch = p->buffer[*pos];
		if (ch >= '0' && ch <= '9')
		{
			*val = *val * 10 + (ch - '0');
			*pos += 1;
			*has = 1;
		}
		else
			break ;
	}
}

static void	parse_digits_oct(t_parser *p, size_t *pos, long *val, int *has)
{
	char	ch;

	while (*pos < p->buffer_size)
	{
		ch = p->buffer[*pos];
		if (ch >= '0' && ch <= '7')
		{
			*val = *val * 8 + (ch - '0');
			*pos += 1;
			*has = 1;
		}
		else
			break ;
	}
}

bool	parse_value(t_parser *parser, t_format_type format, t_token *token)
{
	size_t	pos;
	long	value;
	int		neg;
	int		has;
	int		tmp;

	pos = parser->position;
	value = 0;
	neg = 0;
	has = 0;
	if (pos < parser->buffer_size && parser->buffer[pos] == '-')
	{
		neg = 1;
		pos++;
	}
	else if (pos < parser->buffer_size && parser->buffer[pos] == '+')
		pos++;
	if (format == FORMAT_DECIMAL || format == FORMAT_NUMBER)
		parse_digits_dec(parser, &pos, &value, &has);
	else if (format == FORMAT_OCTAL)
		parse_digits_oct(parser, &pos, &value, &has);
	else
		return (false);
	if (!has)
		return (false);
	token->attribute = ATT_VALUE;
	token->format = format;
	if (neg)
		tmp = -value;
	else
		tmp = value;
	token->data.int_val = tmp;
	token->position = parser->position;
	token->valid = true;
	parser->position = pos;
	parser->context->current_z = (float)tmp;
	return (true);
}

static int	ctx_alloc_arrays(t_ctx_data *ctx, uint32_t attributes)
{
	if (attributes & ATT_VALUE)
	{
		ctx->points = malloc(ctx->array_capacity * sizeof(float));
		if (!ctx->points)
			return (0);
	}
	if (attributes & ATT_COLOR)
	{
		ctx->colors = malloc(ctx->array_capacity * sizeof(uint32_t));
		if (!ctx->colors)
			return (0);
	}
	if (attributes & (ATT_NORMAL | ATT_TEXTURE
			| ATT_FACE | ATT_HEADER | ATT_COMMENT | ATT_CUSTOM))
	{
		ctx->strings = malloc(ctx->array_capacity * sizeof(char *));
		if (!ctx->strings)
			return (0);
	}
	return (1);
}

t_ctx_data	*create_parser_context(uint32_t attributes)
{
	t_ctx_data	*ctx;

	ctx = (t_ctx_data *)malloc(sizeof(t_ctx_data));
	if (!ctx)
		return (NULL);
	memset(ctx, 0, sizeof(t_ctx_data));
	ctx->current_color = 0xffffff;
	ctx->array_capacity = 64;
	if (!ctx_alloc_arrays(ctx, attributes))
	{
		free(ctx->points);
		free(ctx->colors);
		free(ctx->strings);
		free(ctx);
		return (NULL);
	}
	return (ctx);
}